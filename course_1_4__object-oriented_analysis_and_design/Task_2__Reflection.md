# Рефлексия
Сравнение спроектированного и эталонного варианта АТД структуры данных Bounded Stack. 
Ниже представлены оба варианта и заключение по существующим отличиям. Не смотря на то, 
что эталонный вариант представлен в формте псевдокода, в отличие от спроектированного варианта 
(который написан в рамках python нотации) основное сравнение проводится именно на основе 
1. Разделения на команды и запросы
2. Сформулированные пост и пред условия
3. Наличию методов для запроса статусов основных методов АТД 
4. Ответов на прилагающиеся вопросы 

## Эталонный вариант
```pseudocode
abstract class LinkedList<T>

// конструктор
// постусловие: создан новый пустой список
public LinkedList<T> LinkedList();

// команды
// предусловие: список не пуст; 
// постусловие: курсор установлен на первый узел в списке
public void head(); 

// предусловие: список не пуст; 
// постусловие: курсор установлен на последний узел в списке
public void tail(); 

// предусловие: правее курсора есть элемент; 
// постусловие: курсор сдвинут на один узел вправо
public void right(); 

// предусловие: список не пуст; 
// постусловие: следом за текущим узлом добавлен 
// новый узел с заданным значением
public void put_right(T value); 

// предусловие: список не пуст; 
// постусловие: перед текущим узлом добавлен 
// новый узел с заданным значением
public void put_left(T value); 

// предусловие: список не пуст; 
// постусловие: текущий узел удалён, 
// курсор смещён к правому соседу, если он есть, 
// в противном случае курсор смещён к левому соседу,
// если он есть
public void remove();

// постусловие: список очищен от всех элементов
public void clear(); 

// постусловие: в списке удалены все узлы с заданным значением
public void remove_all(T value);

// предусловие: список не пуст;
// постусловие: значение текущего узла заменено на новое
public void replace(T value); 

// постусловие: курсор установлен на следующий узел 
// с искомым значением, если такой узел найден
public void find(T value); 

// запросы
public T get(); // предусловие: список не пуст
public bool is_head();
public bool is_tail();
public bool is_value();
public int size();

// запросы статусов (возможные значения статусов)
public int get_head_status(); // успешно; список пуст
public int get_tail_status(); // успешно; список пуст
public int get_right_status(); // успешно; правее нету элемента
public int get_put_right_status(); // успешно; список пуст
public int get_put_left_status(); // успешно; список пуст
public int get_remove_status(); // успешно; список пуст
public int get_replace_status(); // успешно; список пуст
public int get_find_status(); // следующий найден; 
                   // следующий не найден; список пуст
public int get_get_status(); // успешно; список пуст
// постусловие: новый узел добавлен в хвост списка
  public void add_tail(T value); 

2.2. Операция tail не должна быть сводима к другим операциям, потому что правильная реализация связанного списка 
     подразумевает хранение как условного внутреннего элемента head_pointer (указатель на голову списка), так и 
     условного элемента tail_pointer (указатель на хвост списка). В противном случае операция tail, выраженная через 
     head, right и is_tail, потребовала бы O(N) ресурсов.
     Это пример того, что при проектировании АТД надо обязательно учитывать и эффективность его реализации!
2.3. Операция поиска всех узлов с заданным значением больше не нужна, потому что вместо неё введена логика 
     последовательного перемещения курсора к следующему искомому элементу с нужным значением. 
```

## Спроектированный вариант
```python
class LinkedList[T]:
    ADDTOEMPTY_NIL = 0  # add_to_empty() ещё не вызывалась
    ADDTOEMPTY_OK = 1  # последняя add_to_empty() отработала нормально
    ADDTOEMPTY_ERR = 2  # add_to_empty была вызвана когда список не пуст

    HEAD_NIL = 0  # head() ещё не вызывалась
    HEAD_OK = 1  # последняя head() отработала нормально
    HEAD_ERR = 2  # head() была вызвана когда список пуст

    TAIL_NIL = 0  # tail() ещё не вызывалась
    TAIL_OK = 1  # последняя tail() отработала нормально
    TAIL_ERR = 2  # tail() была вызвана когда список пуст

    RIGHT_NIL = 0  # right() ещё не вызывалась
    RIGHT_OK = 1  # последняя right() отработала нормально
    RIGHT_ERR = 2  # right() была вызвана когда список пуст

    PUTRIGHT_NIL = 0  # put_right() ещё не вызывалась
    PUTRIGHT_OK = 1  # последняя put_right() отработала нормально
    PUTRIGHT_ERR = 2  # put_right() была вызвана когда список пуст

    PUTLEFT_NIL = 0  # put_left() ещё не вызывалась
    PUTLEFT_OK = 1  # последняя put_left() отработала нормально
    PUTLEFT_ERR = 2  # put_left() была вызвана когда список пуст

    REMOVE_NIL = 0  # remove() ещё не вызывалась
    REMOVE_OK = 1  # последняя remove() отработала нормально
    REMOVE_ERR = 2  # remove() была вызвана когда список пуст

    REPLACE_NIL = 0  # replace() ещё не вызывалась
    REPLACE_OK = 1  # последняя replace() отработала нормально
    REPLACE_ERR = 2  # replace() была вызвана когда список пуст

    FIND_NIL = 0  # find() ещё не вызывалась
    FIND_OK = 1  # последняя find() отработала нормально
    FIND_ERR = 2  # find() была вызвана когда список пуст

    GET_NIL = 0  # get() ещё не вызывалась
    GET_OK = 1  # последняя get() отработала нормально
    GET_ERR = 2  # get() была вызвана когда список пуст

    # КОМАНДЫ:

    # предусловие: в списке есть хотя бы один узел
    # постусловие: указатель установлен на первый узел
    def head(self) -> None:
        pass

    # предусловие: в списке есть хотя бы один узел
    # постусловие: указатель установлен на последний узел
    def tail(self) -> None:
        pass

    # предусловие: в списке есть хотя бы один узел, указатель установлен на какой-либо узел, указатель установлен не на последний узел
    # постусловие: указатель установлен на правый ближайший узел от исходного
    def right(self) -> None:
        pass

    # предусловие: в списке есть хотя бы один узел, указатель установлен на какой-либо узел
    # постусловие: справа текущий узел теперь соединен с новым (добавленным) узлом, новый узел соединен с "прошлым" правым узлом текущего узла
    def put_right(self) -> None:
        pass

    # предусловие: в списке есть хотя бы один узел, указатель установлен на какой-либо узел
    # постусловие: слева текущий узел теперь соединен с новым (добавленным) узлом, новый узел соединен с "прошлым" левым узлом текущего узла
    def put_left(self) -> None:
        pass

    # предусловие: в списке есть хотя бы один узел, указатель установлен на какой-либо узел,
    # постусловие: текущий узел удаляется, курсор смещается к правому соседу, если он есть, в противном случае курсор смещается к левому соседу, если он есть
    def remove(self) -> None:
        pass

    # постусловие: указатель не указывает ни на какой узел
    def clear(self) -> None:
        pass

    # предусловие: указатель не установлен не на один из узлов
    # постусловие: добавлен новый узел, указатель установлен на нем
    def add_to_empty(self) -> None:
        pass

    # постусловие: добавлен новый узел в хвост списка, если до этого не было узлов в списке - теперь указаиель установлен на добавленном узле
    def add_tail(self) -> None:
        pass

    # предусловие: указатель установлен на один из узлов
    # постусловие: значение текущего узла изменено
    def replace(self, value) -> None:
        pass

    # предусловие: указатель установлен на один из узлов
    # постусловие: указатель установлен на узел с искомым значением (правее от исходного)
    def find(self, value) -> None:
        pass

    # постусловие: все узлы с искомым значением удалены из списка
    def remove_all(self) -> None:
        pass

    # ЗАПРОСЫ:

    # предусловие: указатель установлен на один из узлов
    def get(self) -> T:
        pass

    def size(self) -> int:
        pass

    # предусловие: указатель установлен на один из узлов
    def is_head(self) -> bool:
        pass

    # предусловие: указатель установлен на один из узлов
    def is_tail(self) -> bool:
        pass

    # предусловие: указатель установлен на один из узлов
    def is_value(self) -> bool:
        pass

    # СТАТУСЫ КОММАНД
    def get_addtoempty_status(self) -> int:
        pass

# Почему операция tail не сводима к другим операциям (если исходить из эффективной реализации)?
# tail не сводима к другим базовым 8 операциям так как при необходимости получить значение последнего элемента пришлось
# бы каждый раз проделать цикл с командой right() с условием которое бы помогало понять что данный узел последний,
# что в свою очередь нарушает момент с тем чтобы ориентироваться именно на концепт указателя, а не связей между узлами


# Операция поиска всех узлов с заданным значением, выдающая список таких узлов, уже не нужна. Почему?
# Так как текущий способ реализации связного списка включает в себя понятие курсора, имеется возможность совместить
# команды head() и множество команд find() для поиска всех значений в списке. Реализация find_all() будет не совсем
# понятна для реализации, так как если реализовать по примеру find(), find_all() просто переберет все подходящие узлы,
# не не получит их значение. Однако присутствует интересный вариант в плане того, чтобы сделать метод find_all
# функцией высшего порядка в которую в качестве аргумента можно передать например get(), remove(), put_left и т.д.

```

# Заключение 
В рамках сравнения представленных АТД, были найден несколько отличий, а именно:
1. Все запросы статусов в эталонном и спроектированном решении совпадает, однако имеются несколько исключений. Вместо 
   статуса для `get_addtoempty_status` был реализован статус для `add_to_empty`, что технически является однаковыми по 
   смыслу, но всё же желательно при введение метода для получения статуса для какого-либо основного метода - специфицировать
   статус именно для этого отдельного "статусного метода".
2. Имеются отличия в статусах, когда в эталонном решении они более уточнены, при каком событии он случается, в спроектированном 
   решении это везде статус ошибки `*_ERR`. Однако так как сами статусы в виде констант в эталонном АТД не реализованы, сложно судить
   стоит ли вводеть в двльнейшем статусы отличные от `*_ERR`, `*_NIL`, `*_OK`.
3. В спроектированном решении также не хватает статуса "не найден" для `get_find_status`, однако это не столь критично
   и в первую очередь зависит от того, считаем ли правильно такой статус ввести или просто его обобщить со статусом ошибки.
4. Из миноритарных отличий можно заметить отсутствие постусловия у конструктора в спроектированном варианте,
   однако здесь постусловие не имеет никаких важных особенностей, лишь имеет статус "создан новый пустой список". Все же
   стоит данно постусловие в будущем прописывать.
5. Субъективно, для некоторых комманд, например `right`, в эталонном решении необходимо прописать дополнительное предусловие того, 
   что список не пуст, ведь иначе возникнет ошибка. Формулировка "правее курсора есть элемент" может ввести в заблуждении.
   Такая же ситуация с запросами `is_head`, `is_value`, `is_tail` ведь они будут неккоректны если список пуст и указатель 
   вообще не установлен.
6. Ответы на оба вопросов затронули основную тему ответов в эталонном решении. В первом случае это неэффективная реализация
   за O(n), во втором же - нововведенная логика курсора. 
# Что фазз тестирование с Atheris на практике ?
## Введение
Фазз тестирование - одна из техник тестирования кода на его корректность. Её основной концепт достаточно прост, мы пытаемся перебирать варианты входных данных для нашей функции чтобы найти те варианты, которые, внезапно, работают не так как мы предполагали.

Однако в этом README.md вы сможете найти не только теоретическое описание фаззинга, но и пример его прикладного применения в python проекте с некоторыми выводами. 
### Подробная информация
Исходя из описания в введение можно подумать что вся суть фазз тестирования в том, чтобы просто брутфорсом перебрать все варианты. Нельзя сказать что это формулировка не правильна, однако её явно можно дополнить. В арсенале фазз тестирования, например, имеются такие концепты как "мутатор", "корпус" и "оракул багов". По сути всё это неотъемлемые части фазз тестирования которые сделают удобнее  и быстрее наш предполагаемый брутфорс. Ведь всегда удобнее использовать корпус, тем самым задав определенную структуру данных которую мы ожидаем на вход, чем наблюдать как самописный фаззер находит ошибки только из-за того что подает вхходные данные не в формате json. Или же всегда приятно использовать мутатор, который будет не просто перебирать все данные подряд, а следуя определенным более эффективным алгоритмам. Ну и конечно же нельзя не упоминуть про то, что специализированная библиотека для фаазинга будет крайне эффективна по скорости, что даст возможность полноценно протестировать даже сложные программы с обилием функцийна проверку.

Также можно упоминуть, что фаззинг бывает трех видов - белый, серый и черный. Грубо говоря, в черном фаззинге мы пытаемся подобрать варианты которые сломают нашу функцию - действуя вслепую, нам конечно доступны разные мутаторы, но видим и имеем мы доступ только к интерфейсу. Белый же фаззинг в первую очередь подразумевает то, что у нашего фаззера есть доступ к внутренностям нашей программы и что более важно возможность анализировать как эти внутренности изменяются. Например, в процессе белого фаззинга, вполне может отслеживаться состояние байт в определенном секторе памяти (с которым взимодействует наша прогамма) и в зависимости от этого направлять мутаторы по тому или иному вектору работы. Серый фаззинг это достаточно широкая полоса между белым и черным, где часть подхода унаследовано от белого, а часть от белого. Поэтому вариаций серого фаззинга, и в целом, того, что можно называть серым фаззингом достаточно обильное количество.
## Примеры на практике
После того как вы в какой-то момент подумаете о том, что фаззинг тестирование вполне себе интересная и потенциально мощная вещь, прежде чем непосредственно приступить к написанию тестов, вам будет необходимо будет проделать некоторую подготовительную работу:
1. Определиться с инструментом
2. Установить все зависимости
3. Освоить уникальные методы внутри выбранного инструмента

Не смотря на то, что пункта всего три, каждый из них может занять достаточное количество времени. В в процессе дальнейшего рассказа я постараюсь это время сэкономить, и оставить его для чего-то несомненно полезного ~~например для игры в XCOM 2~~.

### Как выбрать  инструмент
Однозначно можно порекомендовать Atheris для python, это одназначно лучший выбор, особых конкурентов у него нет. Для других языков программирования - популярные варианты Juzzer, libfuzzer, afl++. Поэтому если решили попробовать фаззинг тестирование на своем python проекте - берите atheris, по нему есть достаточно материалов + его относительно не сложно освоить (по сравнению с конкурентами)
### Установка зависимостей
Одна из самых сложных стадий. Здесь мы конечно рассмотрим только процесс установки atheris, однако другие фаззеры также не слишком легки на подъем в этом деле. Для начала вы можете попробовать установить модуль `atheris` с помощью pip или poetry и вы будете крайне удачливы если у вас это получиться, только что вы сэкономили примерно час. Однако, скорее всего, установка закончится ошибкой, в этом случае необходимо присмотреть к концу текста ошибки и с большой долей вероятности там будет описание того что вам нужно установить чтобы ошибка исчезла, обычно это установка утилиты `cmake`, проекта `clang` и некоторых других сопутствующих зависимостей. Теперь всё что вам останется сделать - это запустить их установку, предварительно освободив околок 50ГБ! места на вашем диске, и примерно после минут 40 все зависимости будут установлены.

### Освоение Atheris 
Теперь можно приступать к изучению нашего фаззера прямо в IDE, и скорее всего не получиться сразу же найти подходящего и понятного примера, поэтому небольшой вводный скрипт я оставлю ниже, однако стоит помнить что в самом atheris гораздо больше функций чем продемонстрировано ниже, особенно полезны импортируемые из atheris декораторы. 
Запустить можно командой `python main.py`, а если желаете ограничить количество итераций модуля по вашему коду `python3 -m coverage run main.py.py -atheris_runs=10000`. 
Также лучше использовать python 3.10. В рамках моих испытаний, python 3.12 так и не захотел корректно работать с atheris.
```python
import atheris  
import sys  
  
  
@atheris.instrument_func  
def check_permission(permission: str) -> bool:  
    if permission == 'fuzzing_is_available':  
        return False  
    elif permission == 'fuzzing_is_not_available':  
        return True  
    elif permission == 'check_permissionnn ':  
        return 100/0  # ошибка здесь
  
    return True  
  
  
@atheris.instrument_func  
def do_calc(permission: str) -> int:  
    is_available = check_permission(permission)  
  
    if is_available:  
        return 2 + 2  
    else:  
        return -1  
  
  
def run_fuzzin(data: bytes):  
    dp = atheris.FuzzedDataProvider(data)  
  
    permission_legth = dp.ConsumeIntInRange(0, 32)  
    permission = dp.ConsumeUnicodeNoSurrogates(permission_legth)  
  
    do_calc(permission)  
  
  
atheris.Setup(sys.argv, run_fuzzin)  
atheris.Fuzz()
```

## Выводы по использованию
Я попробовал внедрить atheris в продакшен python проект (примерно 4000 строк) и получил следующие результаты:
* В 50% функций были обнаружены не покрытые случаи, пусть и не самые опасные, но всё же.
* Больше всего atheris обнаружил непредвиденных ошибок в функциях и методах которые парсили приходящие json-ы, что явно намекнуло на то, что стоит пересмотреть то, как эти алгоритмы разбора написаны.
* Краш-репорты получающиеся по итогу работы atheris, не совсем удобно просматривать в IDE, поэтому использовал nano.
* Быстро встроить atheris в gitlab пайплайн оказалось задачей не простой и не быстрой, в частности из-за формата сохранения ошибок в виде файлов, а не выводе в std.

Как итог, можно точно сказать, что atheris полезный инструмент, который сможет подсветить не одну ошибку в вашем проекте, однако, всё же сложноват во время освоения и первого использования.
# Now I would like to talk about naming methods and functions, expressive and clear naming of these constructs is
# extremely important - especially the fact that it allows you to understand which functions should be decomposed.
# Next, we will look at examples of changing the names of methods and functions from unsuccessful to successful with
# my comments and explanations.


# Example №1
# Context: This function accesses the private server via the api and returns court cases.
# Comments: The main edit is the deprecating of the article 'the' which unnecessarily overloads the function name.

# WAS
...
def get_the_court_cases(iin_or_bin: str, organization: str, year: int, month: int, page: int) -> list[Case]:
...

# BECAME
...
def get_court_cases(iin_or_bin: str, organization: str, year: int, month: int, page: int) -> list[Case]:
...

# Example №2
# Context: The presented function helps to check the legitimacy of the court case, namely the current status.
# Comments: In this case, the particles 'the' and 'of' were removed from the function name, and it was possible to
# shorten the function quite strongly without losing meaning, and the expressiveness of the name has grown even more.

# WAS
...
def get_the_legitimacy_status_of_case(case_number: str) -> str:
...

# BECAME
...
def get_case_legitimacy_status(case_number: str) -> str:
...

# Example №3
# Context: The function is a predicate that allows you to check whether the specified pair of xmin and password
# parameters is valid by means of an internal API request.
# Comments: It was decided to seriously rework the function to increase expressiveness, after edits you can look at the
# function (which is not part of the class) and understand exactly what it does.

# WAS
...
def check_the_reliability_of_the_credentials(xin: str, password: str) -> bool:
...

# BECAME
...
def is_court_account_credentials_valid(xin: str, password: str) -> bool:
...

# Example №4
# Context: since you have to interact within the framework of the program with quite specific API interfaces,
# a separate function was created to generate all the data that the request will be supplied with.
# Comments: Here it was decided to shift the emphasis from the element generated by the function to the main meaning
# with maximizing the description of the final result - that the request itself is not sent, only the necessary
# metadata is generated.

# WAS
...
def generate_cookies_headers_and_data_for_request(jsession_value: str, view_state_value: str, xin: str, password: str) -> tuple[dict]:
...

# BECAME
...
def generate_auth_request_metadata(jsession_value: str, view_state_value: str, xin: str, password: str) -> tuple[dict]:
...

# Example №5
# Context: In this example, the function is used to obtain a binary representation of a file using sqlite, but also
# provides for the case when the file could not be converted to a binary format.
# Comments: As a result, the name was changed to a more appropriate one that really describes the action of the
# function. Typhints are also added.

# WAS
...
def review_file_validate(message):
...

# BECAME
...
def convert_file_to_binary(message: Message) -> Optional[Binary]:
...

# Example №6
# Context: The function was designed to return the user's comment ready to be saved to the database,
# aggregating text data from several places (objects).
# Comments: I changed the name to 'get_user_review_comment' which describes what we get at the output of this
# function - describing its main functionality.

# WAS
...
def review_data_validate(message, review_data, user_data):
...

# BECAME
...
def get_user_review_comment(message: Message, review_data: Review, user_data: User) -> str:
...

# Example №7
# Context: Here is a void function that contains a certain amount of functionality, ranging from initializing
# workflow to sending messages.
# Comments: Since the void function was large enough, it was reasonable to decompose it into two composite functions,
# each of which was given a name in accordance with the function it was executing.

# WAS
...
def operator_conversation_workflow(message, interlocutor_chat_id, user_data, session_id):
...

# BECAME
...
def operator_conversation_workflow_initialize(message: Message, interlocutor_chat_id: int, user_data: User, session_id: int) -> None:

def notice_operator_about_conversation_workflow_initialize(message: Message, interlocutor_chat_id: int, user_data: User, session_id: int) -> None:
...

# Example №8
# Context: The example below shows the Library class method, which method is supposed to return a dictionary grouped by the
# date of registration of users.
# Comments:  There are many inaccuracies in the original name, for example, using the context for the word 'day' -
# the day of what, registration or other activity. Also, the 'new' characteristic is not suitable for the name,
# since the dictionary returns with all users for the entire time

# WAS
...
class Library(models.Model):
    def group_new_users_by_day(self, year=None, month=None):
...

# BECAME
...
class Library(models.Model):
    def get_users_grouped_by_registration_date(self, year=None, month=None) -> dict:
...

# Example №9
# Context: The class described is a representation of a Reading room that can contain several readers of a book
# and other information.
# Comments: The word 'all' was removed from the name because of the redundancy of the clarification, it is worth
# starting from the fact that 'get_books' are all the books of the reading room, and if some method returns some
# specific books, specify which ones in these methods.

# WAS
...
class ReadingRoom(models.Model):
     def get_all_books(self):
...

# BECAME
...
class ReadingRoom(models.Model):
     def get_books(self) -> list[Book]:
...

# Example №10
# Context: The Server class is an implementation of a server, following the example of a Client-Server scheme,
# with the functions of sending messages, accepting, etc.
# Comments: The main monumental edit in the name of the 'broadcast' method is an explanation that it is about the
# message, that is, about the broadcast, about the action that can be called.

# WAS
...
class Server:
	def broadcast(self, label: str, message: str, except_list: list[User] = None):
...

# BECAME
...
class Server:
	def send_broadcast_message(self, label: str, message: str, except_list: Optional[list[User]]) -> None:
...

# Example №11
# Context: The presented method is also part of the Server class, responsible for adding the user, or rather the
# address (socket) of the user to the pool of server clients.
# Comments: Here we could observe an example of bad naming, namely the use of a rather abstract word 'process',
# which makes the method completely opaque to understand.  It is much more expressive to display the essence of the
# method by using the word initialization, since this is what the server does in this method.

# WAS
...
class Server:
    def process_user(self, conn: Socket):
...

# BECAME
...
class Server:
    def initialize_user(self, conn: Socket) -> None:
...

# Example №12
# Context: This function is taken from a class that emulates server operation using sockets.
# Comments: Within the framework of the server class, it is logical to use the concept of server installation rather
# than the term 'kill' since such is usually used in relation to processes and connections, and therefore such naming
# for the 'HttpServer' class can confuse the user what exactly this one does.

# WAS
...
class HTTPServer:
    def kill(self):
...

# BECAME
...
class HTTPServer:
    def stop(self) -> None:
...

